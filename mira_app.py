"""
This is the main backend for Mira â€” Your AI Real Estate Co-Pilot.
It receives client intake forms, stores them, and will handle contract generation and agent assignment.
"""

import os
import json
from fastapi import FastAPI, Request, BackgroundTasks, Body
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

# Single FastAPI app instance
app = FastAPI()

# Templates setup
templates = Jinja2Templates(directory="templates")

# Database helper function
def get_database_url():
    DATABASE_URL = os.getenv("DATABASE_URL")
    if DATABASE_URL.startswith("postgres://"):
        DATABASE_URL = DATABASE_URL.replace("postgres://", "postgresql+asyncpg://", 1)
    elif DATABASE_URL.startswith("postgresql://"):
        DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)
    return DATABASE_URL

# Contract generation function (placeholder - you'll need to implement this)
def generate_demo_contract(lead_dict):
    """Generate a demo contract for the given lead"""
    import os
    from docx import Document
    
    # Create generated_contracts directory if it doesn't exist
    os.makedirs("generated_contracts", exist_ok=True)
    
    # Create a simple demo contract
    doc = Document()
    doc.add_heading(f"Service Agreement - {lead_dict['name']}", 0)
    doc.add_paragraph(f"Client: {lead_dict['name']}")
    doc.add_paragraph(f"Email: {lead_dict['email']}")
    doc.add_paragraph(f"Service: {lead_dict['service']}")
    doc.add_paragraph("This is a demo contract generated by Mira AI Real Estate Co-Pilot.")
    
    file_path = f"generated_contracts/demo_contract_{lead_dict['id']}.docx"
    doc.save(file_path)
    return file_path

# Root endpoint
@app.get("/")
async def root():
    return {"status": "Mira backend is alive ðŸš€"}

# Dashboard endpoint
@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    DATABASE_URL = get_database_url()
    engine = create_async_engine(DATABASE_URL, echo=False)

    async with engine.connect() as conn:
        result = await conn.execute(text("SELECT id, name, email, service, status FROM leads"))
        raw_leads = result.fetchall()

    await engine.dispose()

    # Organize leads by status
    leads_by_status = {
        "ðŸ†• New": [],
        "ðŸ“„ Contract Generated": [],
        "âœï¸ DocuSign Ready": [],
        "âœ… Completed": [],
        "â“ Uncategorized": []
    }

    # Define normalized mapping
    status_map = {
        "new": "ðŸ†• New",
        "contract generated": "ðŸ“„ Contract Generated",
        "docusign ready": "âœï¸ DocuSign Ready",
        "completed": "âœ… Completed"
    }

    for lead in raw_leads:
        lead_dict = {
            "id": lead[0],
            "name": lead[1],
            "email": lead[2],
            "service": lead[3],
            "status": lead[4],
        }

        # Normalize incoming DB status
        normalized = (lead_dict["status"] or "").strip().lower()
        status_key = status_map.get(normalized, "â“ Uncategorized")

        # Bucket the lead
        leads_by_status[status_key].append(lead_dict)

    return templates.TemplateResponse(
        "dashboard.html",
        {"request": request, "leads": leads_by_status}
    )

# Tally webhook endpoint
@app.post("/tally_webhook")
async def tally_webhook(payload: dict = Body(...)):
    print("ðŸ“© Incoming Tally Webhook Payload:", payload)

    # Extract useful fields
    name, email, service = "Unknown", "unknown@example.com", "General Inquiry"
    
    for ans in payload.get("data", {}).get("fields", []):
        label = ans.get("label", "").lower()
        if "full legal name" in label:
            name = ans.get("value") or name
        elif label == "email" and ans.get("value"):
            email = ans.get("value")
        elif "how can mira help you today?" in label:
            choice_ids = ans.get("value", [])
            options = {opt["id"]: opt["text"] for opt in ans.get("options", [])}
            if choice_ids:
                service = options.get(choice_ids[0], service)

    DATABASE_URL = get_database_url()
    engine = create_async_engine(DATABASE_URL, echo=False)

    async with engine.begin() as conn:
        await conn.execute(
            text("""
                INSERT INTO leads (name, email, service, status, raw_data)
                VALUES (:name, :email, :service, :status, :raw_data)
            """),
            {
                "name": name,
                "email": email,
                "service": service,
                "status": "New",
                "raw_data": json.dumps(payload)
            }
        )

    await engine.dispose()
    return {"success": True, "inserted": {"name": name, "email": email, "service": service}}

# Manual contract generation endpoint
@app.get("/generate_contract/{lead_id}")
async def generate_contract(lead_id: int):
    DATABASE_URL = get_database_url()
    engine = create_async_engine(DATABASE_URL, echo=False)

    async with engine.connect() as conn:
        result = await conn.execute(
            text("SELECT id, name, email, service, status FROM leads WHERE id = :id"),
            {"id": lead_id}
        )
        row = result.fetchone()

    await engine.dispose()

    if not row:
        return {"error": f"Lead with id {lead_id} not found"}

    # Convert SQLAlchemy row -> dict
    lead_dict = {
        "id": row[0],
        "name": row[1],
        "email": row[2],
        "service": row[3],
        "status": row[4],
    }

    # Call the contract generator function
    contract_path = generate_demo_contract(lead_dict)

    return {
        "success": True,
        "contract_created": contract_path,
        "lead": lead_dict
    }

# Endpoint to download contract by lead_id
@app.get("/download_contract/{lead_id}")
async def download_contract(lead_id: int):
    file_path = f"generated_contracts/demo_contract_{lead_id}.docx"
    if not os.path.exists(file_path):
        return {"error": f"No contract found for lead {lead_id}"}
    return FileResponse(
        path=file_path,
        filename=f"demo_contract_{lead_id}.docx",
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    )
    # Endpoint to update lead status
from fastapi import Body

@app.post("/update_status/{lead_id}")
async def update_status(lead_id: int, new_status: str = Body(..., embed=True)):
    DATABASE_URL = get_database_url()
    engine = create_async_engine(DATABASE_URL, echo=False)

    async with engine.begin() as conn:
        await conn.execute(
            text("UPDATE leads SET status = :status WHERE id = :id"),
            {"status": new_status, "id": lead_id}
        )

    await engine.dispose()
    return {"success": True, "updated_id": lead_id, "new_status": new_status}